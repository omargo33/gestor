package view.utilidades;import io.jsonwebtoken.SignatureAlgorithm;import java.security.Key;import javax.crypto.spec.SecretKeySpec;import javax.xml.bind.DatatypeConverter;/** * Clase que contiene la logica para el proceso de conciliacion. * * @author omargo33@hotmail.com */public class GenerateKey {    /**     * Identificador para firmar y verificar un token de acceso     */    public static final String ACCESS_TOKEN = "9962640473";    /**     * Identificador para firmar y verificar un token de refrescamiento     */    public static final String REFRESH_TOKEN = "2598245542";    /**     * Llave para encripcion de datos     */    public static final String LLAVE_SECRETA = "1234567890123456" + "1234567890123456";    /**     * Nombre del metodo que realiza el refrescamiento de un token     */    public static final String METODO_REFRESH_TOKEN = "JWTRefresh";    private SignatureAlgorithm signatureAlgorithm;    private Key signingKey;    public GenerateKey() {        this.signatureAlgorithm = null;        this.signingKey = null;    }    public void firmar() {        // Se define el algoritmo que sera utilizado para firmar el token        signatureAlgorithm = SignatureAlgorithm.HS256;        //Se procede a firmar el token con la ayuda de una llave secreta        byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(GenerateKey.LLAVE_SECRETA);        signingKey = new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());    }    public SignatureAlgorithm getSignatureAlgorithm() {        return signatureAlgorithm;    }    public void setSignatureAlgorithm(SignatureAlgorithm signatureAlgorithm) {        this.signatureAlgorithm = signatureAlgorithm;    }    public Key getSigningKey() {        return signingKey;    }    public void setSigningKey(Key signingKey) {        this.signingKey = signingKey;    }}