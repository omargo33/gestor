package view.utilidades;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.logging.Level;import java.util.logging.Logger;import javax.el.ELContext;import javax.el.ExpressionFactory;import javax.el.MethodExpression;import javax.el.ValueExpression;import javax.faces.application.FacesMessage;import javax.faces.context.FacesContext;import javax.faces.model.SelectItem;import oracle.adf.model.AttributeBinding;import oracle.adf.model.BindingContext;import oracle.adf.model.DataControlFrame;import oracle.adf.model.binding.DCBindingContainer;import oracle.adf.model.binding.DCIteratorBinding;import oracle.adf.model.binding.DCParameter;import oracle.binding.BindingContainer;import oracle.binding.ControlBinding;import oracle.binding.OperationBinding;import oracle.jbo.ApplicationModule;import oracle.jbo.Key;import oracle.jbo.Row;import oracle.jbo.RowSetIterator;import oracle.jbo.uicli.binding.JUCtrlValueBinding;import org.apache.commons.lang3.StringUtils;/** * A series of convenience functions for dealing with ADF Bindings * * Custom for: * @author omargo33@hotmail.com * */public class ADFUtils {    /**     * Find an iterator binding in the current binding container by name.     * @param iteratorName iterator binding name     * @return iterator binding     */    public static DCIteratorBinding getIterator(String iteratorName) {        DCIteratorBinding iter = getDCBindingContainer().findIteratorBinding(iteratorName);        return iter;    }    /**     * Constant for signalling failed SRService checkout during eager test.     */    public static final String SRSERVICE_CHECKOUT_FAILED = "SRServiceFailed";    /**     * Get List of ADF Faces SelectItem for an iterator binding.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iteratorName ADF iterator binding name     * @param valueAttrName name of the value attribute to use     * @param displayAttrName name of the attribute from iterator rows to display     * @return ADF Faces SelectItem for an iterator binding     */    public static List<SelectItem> selectItemsForIteratorTres(String iteratorName, String valueAttrName,                                                              String displayAttrName) {        return selectItemsForTres(findIterator(iteratorName), valueAttrName, displayAttrName);    }    /**     * Get List of ADF Faces SelectItem for an iterator binding with description.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iteratorName ADF iterator binding name     * @param valueAttrName name of the value attribute to use     * @param displayAttrName name of the attribute from iterator rows to display     * @param descriptionAttrName name of the attribute to use for description     * @return ADF Faces SelectItem for an iterator binding with description     */    public static List<SelectItem> selectItemsForIteratorCuatro(String iteratorName, String valueAttrName,                                                                String displayAttrName, String descriptionAttrName) {        return selectItemsForCuatro(findIterator(iteratorName), valueAttrName, displayAttrName, descriptionAttrName);    }    /**     * Get a List of attribute values for an iterator.     *     * @param iter iterator binding     * @param valueAttrName name of value attribute to use     * @return List of attribute values     */    public static List attributeListForIterator(DCIteratorBinding iter, String valueAttrName) {        List<Object> attributeList = new ArrayList<Object>();        for (Row r : iter.getAllRowsInRange()) {            attributeList.add(r.getAttribute(valueAttrName));        }        return attributeList;    }    /**     * Get List of ADF Faces SelectItem for an iterator binding with description.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iter ADF iterator binding     * @param valueAttrName name of value attribute to use for key     * @param displayAttrName name of the attribute from iterator rows to display     * @param descriptionAttrName name of the attribute for description     * @return ADF Faces SelectItem for an iterator binding with description     */    private static List<SelectItem> selectItemsForCuatro(DCIteratorBinding iter, String valueAttrName,                                                         String displayAttrName, String descriptionAttrName) {        List<SelectItem> selectItems = new ArrayList<SelectItem>();        for (int i = 0; i < iter.getRangeSize(); i++) {            if (iter.getRowAtRangeIndex(i) != null) {                Row r = iter.getRowAtRangeIndex(i);                selectItems.add(new SelectItem(r.getAttribute(valueAttrName), (String) r.getAttribute(displayAttrName),                                               (String) r.getAttribute(descriptionAttrName)));            }        }        return selectItems;    }    /**     * Get List of ADF Faces SelectItem for an iterator binding.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iter ADF iterator binding     * @param valueAttrName name of value attribute to use for key     * @param displayAttrName name of the attribute from iterator rows to display     * @return ADF Faces SelectItem for an iterator binding     */    private static List<SelectItem> selectItemsForTres(DCIteratorBinding iter, String valueAttrName,                                                       String displayAttrName) {        List<SelectItem> selectItems = new ArrayList<SelectItem>();        for (Row r : iter.getAllRowsInRange()) {            selectItems.add(new SelectItem(r.getAttribute(valueAttrName), (String) r.getAttribute(displayAttrName)));        }        return selectItems;    }    /**     * Get List of ADF Faces SelectItem for an iterator binding.     *     * Uses the rowKey of each row as the SelectItem key.     *     * @param iter ADF iterator binding     * @param displayAttrName name of the attribute from iterator rows to display     * @return List of ADF Faces SelectItem for an iterator binding     */    public static List<SelectItem> selectItemsByKeyForIterator(DCIteratorBinding iter, String displayAttrName) {        List<SelectItem> selectItems = new ArrayList<SelectItem>();        for (Row r : iter.getAllRowsInRange()) {            selectItems.add(new SelectItem(r.getKey(), (String) r.getAttribute(displayAttrName)));        }        return selectItems;    }    /**Mensaje para conocer el dato de un campo en particular.     *     * @param bindings     * @param iterator     * @param campo     * @return     */    public static Object getPageDefCamposValue(BindingContainer bindings, String iterator, String campo) {        DCBindingContainer bc = (DCBindingContainer) bindings;        if (bc != null) {            DCIteratorBinding normIter = bc.findIteratorBinding(iterator);            RowSetIterator rsi = normIter.getRowSetIterator();            if (rsi.getRowCount() > 0) {                String[] attNames = rsi.getRowAtRangeIndex(0).getAttributeNames();                for (int j = 0; j < attNames.length; j++) {                    if (attNames[j].equalsIgnoreCase(campo)) {                        return rsi.getRowAtRangeIndex(0).getAttributeValues()[j];                    }                }            }        }        return null;    }    /**Metodo para cambiar el contenido de un campo en particular.     *     * @param bindings     * @param iterator     * @param campo     * @param valor     * @return     */    public static boolean setPageDefCamposValue(BindingContainer bindings, String iterator, String campo,                                                Object valor) {        DCBindingContainer bc = (DCBindingContainer) bindings;        if (bc != null) {            DCIteratorBinding normIter = bc.findIteratorBinding(iterator);            RowSetIterator rsi = normIter.getRowSetIterator();            if (rsi.getRowCount() > 0) {                String[] attNames = rsi.getRowAtRangeIndex(0).getAttributeNames();                for (int j = 0; j < attNames.length; j++) {                    if (attNames[j].equalsIgnoreCase(campo)) {                        rsi.getRowAtRangeIndex(0).setAttribute(j, valor);                        return true;                    }                }            }        }        return false;    }    /**     * @param bindings     * @param attributeName     * @param value     */    public static void setPageBoundAttributeValue(BindingContainer bindings, String attributeName, Object value) {        AttributeBinding binding = (AttributeBinding) bindings.getControlBinding(attributeName);        binding.setInputValue(value);    }    /**Metodo para ejecutar la creacion de un registro con commit y rollback y mensajes a las acciones.     *     * @param bindings     * @param metodo     * @param commit     * @param rollback     * @param mensajeError     * @param mensajeSatisfactorio     * @return si se ejecuto correctamente     */    public static boolean ejecutaFormulario(BindingContainer bindings, String metodo, String commit, String rollback,                                            String mensajeError, String mensajeSatisfactorio) {        return ejecutaFormulario(bindings, metodo, commit, rollback, mensajeError, mensajeSatisfactorio, null);    }    /**Metodo para ejecutar la creacion de un registro con commit y rollback y mensajes a las acciones.     *     * @param bindings     * @param metodo     * @param commit     * @param rollback     * @param mensajeError     * @param mensajeSatisfactorio     * @param parametros     * @return     */    @SuppressWarnings("unchecked")    public static boolean ejecutaFormulario(BindingContainer bindings, String metodo, String commit, String rollback,                                            String mensajeError, String mensajeSatisfactorio, Map parametros) {        OperationBinding oper = bindings.getOperationBinding(metodo);        if (parametros != null) {            oper.getParamsMap().putAll(parametros);        }        try {            oper.execute();            escribirError(oper, "ejecutaFormulario()-" + metodo);            if (oper.getErrors().isEmpty()) {                return commitRollback(bindings, commit, rollback, mensajeError, mensajeSatisfactorio);            } else {                setMensajeInformacion(mensajeError + " Comando");                return false;            }        } catch (Exception e) {            Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)                .log(Level.WARNING, StringUtils.joinWith(" ", "ejecutaFormulario", mensajeError, metodo, e.toString()));            return false;        }    }    /**Metodo para ejecutar una accion de un binding container.     *     * @param bindings     * @param accion     * @param mensajeError     * @param mensajeSatisfactorio     * @return     */    public static boolean ejecutaAction(BindingContainer bindings, String accion, String mensajeError,                                        String mensajeSatisfactorio) {        return ejecutaAction(bindings, accion, mensajeError, mensajeSatisfactorio, null);    }    /**Metodo para ejecutar una accion de un binding container.     *     * @param bindings     * @param accion     * @param mensajeError     * @param mensajeSatisfactorio     * @param parametros     * @return     */    @SuppressWarnings("unchecked")    public static boolean ejecutaAction(BindingContainer bindings, String accion, String mensajeError,                                        String mensajeSatisfactorio, Map parametros) {        OperationBinding oper = bindings.getOperationBinding(accion);        if (parametros != null) {            oper.getParamsMap().putAll(parametros);        }        oper.execute();        escribirError(oper, "ejecutaAction()-" + accion);        if (!oper.getErrors().isEmpty()) {            setMensajeError(mensajeError);            return false;        }        setMensajeInformacion(mensajeSatisfactorio);        return true;    }    /**Metodo para ejecutar una accion de un binding container y que devuelve un mensaje predefinido.     *     * @param bindings     * @param accion     * @return     */    public static boolean ejecutaActionConReturn(BindingContainer bindings, String accion) {        return ejecutaActionConReturn(bindings, accion, null);    }    /**Metodo para ejecutar una accion de un binding container y que devuelve un mensaje predefinido.     *     * @param bindings     * @param accion     * @param parametros     * @return     */    @SuppressWarnings("unchecked")    public static boolean ejecutaActionConReturn(BindingContainer bindings, String accion, Map parametros) {        OperationBinding oper = bindings.getOperationBinding(accion);        if (parametros != null) {            oper.getParamsMap().putAll(parametros);        }        Object result = oper.execute();        escribirError(oper, "ejecutaActionConReturn()-" + accion);        if (oper.getErrors().isEmpty()) {            if (result != null && result.getClass()                                        .getName()                                        .equalsIgnoreCase("java.lang.String"))                setMensajeInformacion((String) result);            return true;        } else            return false;    }    /**Metodo para ejecutar una accion de un binding container y que devuelve un mensaje predefinido.     *     * @param bindings     * @param accion     * @return     */    public static Object ejecutaActionConReturn(BindingContainer bindings, String accion, boolean status) {        return ejecutaActionConReturn(bindings, accion, status, null);    }    /**Metodo para ejecutar una accion de un binding container y que devuelve un mensaje predefinido.     *     * @param bindings     * @param accion     * @param parametros     * @return     */    @SuppressWarnings("unchecked")    public static Object ejecutaActionConReturn(BindingContainer bindings, String accion, boolean status,                                                Map parametros) {        status = true;        OperationBinding oper = bindings.getOperationBinding(accion);        if (parametros != null) {            oper.getParamsMap().putAll(parametros);        }        Object result = oper.execute();        escribirError(oper, "ejecutaActionConReturn()-" + accion);        if (oper.getErrors().isEmpty())            return result;        return null;    }    /**Metodo para ejecutar el grabado de un elemento Many Shuttle y su confirmacion de commit     * y rollback arbitraria.     *     * @param bindings     * @param iteratorNombre     * @param campoInidces     * @param confirmar     * @param rollback     * @param mensajeError     * @param mensajeSatisfactorio     * @param productIds     * @return     */    public static boolean updateSelectManyShuttle(BindingContainer bindings, String iteratorNombre, String campoInidces,                                                  String confirmar, String rollback, String mensajeError,                                                  String mensajeSatisfactorio, List productIds) {        if (productIds != null && productIds.size() >= 0) {            DCBindingContainer bc = (DCBindingContainer) bindings;            if (bc != null) {                DCIteratorBinding normIter = bc.findIteratorBinding(iteratorNombre);                RowSetIterator rsi = normIter.getRowSetIterator();                for (int i = rsi.getRowCount(); i > 0; i--) {                    Row currentRow = rsi.getRowAtRangeIndex(i - 1);                    if (currentRow != null) {                        currentRow.remove();                    }                }                rsi.closeRowSetIterator();                for (Object productIdToAdd : productIds) {                    Row newRow = normIter.getRowSetIterator().createRow();                    normIter.getRowSetIterator().insertRow(newRow);                    try {                        newRow.setAttribute(campoInidces, productIdToAdd);                    } catch (Exception e) {                        Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)                            .log(Level.WARNING, StringUtils.joinWith(" ", mensajeError, productIdToAdd, e.toString()));                    }                }                return commitRollback(bindings, confirmar, rollback, mensajeError, mensajeSatisfactorio);            }        }        return false;    }    /**     * @param bindings     * @param iteratorNombre     * @param campoInidces     * @param campoCodigo     * @param valor     * @param confirmar     * @param rollback     * @param mensajeError     * @param mensajeSatisfactorio     * @param productIds     * @return     */    public static boolean updateSelectManyShuttleCodigo(BindingContainer bindings, String iteratorNombre,                                                        String campoInidces, String campoCodigo, Object valor,                                                        String confirmar, String rollback, String mensajeError,                                                        String mensajeSatisfactorio, List productIds) {        if (productIds != null && productIds.size() >= 0) {            DCBindingContainer bc = (DCBindingContainer) bindings;            if (bc != null) {                DCIteratorBinding normIter = bc.findIteratorBinding(iteratorNombre);                RowSetIterator rsi = normIter.getRowSetIterator();                for (int i = rsi.getRowCount(); i > 0; i--) {                    Row currentRow = rsi.getRowAtRangeIndex(i - 1);                    if (currentRow != null) {                        currentRow.remove();                    }                }                rsi.closeRowSetIterator();                for (Object productIdToAdd : productIds) {                    Row newRow = normIter.getRowSetIterator().createRow();                    normIter.getRowSetIterator().insertRow(newRow);                    try {                        newRow.setAttribute(campoInidces, productIdToAdd);                        newRow.setAttribute(campoCodigo, valor);                    } catch (Exception e) {                        Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)                            .log(Level.WARNING, StringUtils.joinWith(" ", mensajeError, productIdToAdd, e.toString()));                    }                }                return commitRollback(bindings, confirmar, rollback, mensajeError, mensajeSatisfactorio);            }        }        return false;    }    /**Metodo para ejecutar el rollback y el commit     * Ademas incluye mensajes de Ok y error.     *     * Si tiene accion de confirmacion     * Crea Operador confirar     * Ejecuta la confirmacion     * Si hay errores     * Crea Operador rollback     * Ejecuta la rollback     * Si no hay errores     * Si hay mensaje de error     * Muestra el mensaje de error     * Caso contrario     * Muestra mensaje de Crash     * Else     * Si hay mensaje de confirmacion     * Muestra mensaje     * devuelve true     * devuelde false     *     * @param bindings     * @param confirmar     * @param rollback     * @param mensajeError     * @param mensajeSatisfactorio     * @return     */    public static boolean commitRollback(BindingContainer bindings, String confirmar, String rollback,                                         String mensajeError, String mensajeSatisfactorio) {        if (confirmar != null) {            OperationBinding oper = bindings.getOperationBinding(confirmar);            oper.execute();            escribirError(oper, ".commitRollback()-commit");            if (!oper.getErrors().isEmpty()) {                oper = bindings.getOperationBinding(rollback);                oper.execute();                escribirError(oper, ".commitRollback()-rollback");                setMensajeError(mensajeError);                return false;            }            setMensajeInformacion(mensajeSatisfactorio);            return true;        }        return false;    }    /**Metodo para escribir el error en un log de errores.     *     * Si hay errores     *  Recorre el listado de errores     *  Escribe los errores en el archivo de log.     *     * @param oper     * @param metodo     */    private static String escribirError(OperationBinding oper, String metodo) {        String ultimaRespuesta = "";        if (!oper.getErrors().isEmpty())            for (Object a : oper.getErrors()) {                ultimaRespuesta = a.toString();                Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)                    .log(Level.WARNING, StringUtils.joinWith(" ", metodo, a.toString()));            }        return ultimaRespuesta;    }    /**     * @param mensaje     */    public static void setMensajeError(String mensaje) {        setMensaje(mensaje, FacesMessage.SEVERITY_ERROR);    }    /**     * @param mensaje     */    public static void setMensajeInformacion(String mensaje) {        setMensaje(mensaje, FacesMessage.SEVERITY_INFO);    }    /**Metodo para mostrar un mensaje de cualquier severidas     *     * Si hay un mensaje que mostrar     *  Crea el Objeto de mensaje     *  Pone la severidad     *  Pone el mensaje     *  Muestra el mensaje     *     * @param mensaje     * @param severity     */    private static void setMensaje(String mensaje, javax.faces.application.FacesMessage.Severity severity) {        if (mensaje != null) {            FacesMessage fm = new FacesMessage();            fm.setSeverity(severity);            fm.setSummary(mensaje);            FacesContext.getCurrentInstance().addMessage(":)", fm);        }    }    /**Metodo para actualizar un elemento SelectManyShuttle.     *     * @param bindings     * @param iteratorNombre     * @param campoInidces     * @param campoCodigo     * @param valor     * @param campoCodigo2     * @param valor2     * @param confirmar     * @param rollback     * @param mensajeError     * @param mensajeSatisfactorio     * @param productIds     * @return     */    public static boolean updateSelectManyShuttleCodigoPadre(BindingContainer bindings, String iteratorNombre,                                                             String campoInidces, String campoCodigo, Object valor,                                                             String campoCodigo2, Object valor2, String confirmar,                                                             String rollback, String mensajeError,                                                             String mensajeSatisfactorio, List productIds) {        if (productIds != null && productIds.size() >= 0) {            DCBindingContainer bc = (DCBindingContainer) bindings;            if (bc != null) {                DCIteratorBinding normIter = bc.findIteratorBinding(iteratorNombre);                RowSetIterator rsi = normIter.getRowSetIterator();                for (int i = rsi.getRowCount(); i > 0; i--) {                    Row currentRow = rsi.getRowAtRangeIndex(i - 1);                    if (currentRow != null) {                        currentRow.remove();                    }                }                rsi.closeRowSetIterator();                for (Object productIdToAdd : productIds) {                    Row newRow = normIter.getRowSetIterator().createRow();                    normIter.getRowSetIterator().insertRow(newRow);                    try {                        newRow.setAttribute(campoInidces, productIdToAdd);                        newRow.setAttribute(campoCodigo, valor);                        newRow.setAttribute(campoCodigo2, valor2);                    } catch (Exception e) {                        Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)                            .log(Level.WARNING, StringUtils.joinWith(" ", mensajeError, productIdToAdd, e.toString()));                    }                }                return commitRollback(bindings, confirmar, rollback, mensajeError, mensajeSatisfactorio);            }        }        return false;    }    /**     * Get application module for an application module data control by name.     * @param name application module data control name     * @return ApplicationModule     */    public static ApplicationModule getApplicationModuleForDataControl(String name) {        return (ApplicationModule) JSFUtils.resolveExpression("#{data." + name + ".dataProvider}");    }    /**     * A convenience method for getting the value of a bound attribute in the     * current page context programatically.     * @param attributeName of the bound value in the pageDef     * @return value of the attribute     */    public static Object getBoundAttributeValue(String attributeName) {        return findControlBinding(attributeName).getInputValue();    }    /**     * A convenience method for setting the value of a bound attribute in the     * context of the current page.     * @param attributeName of the bound value in the pageDef     * @param value to set     */    public static void setBoundAttributeValue(String attributeName, Object value) {        findControlBinding(attributeName).setInputValue(value);    }    /**     * Returns the evaluated value of a pageDef parameter.     * @param pageDefName reference to the page definition file of the page with the parameter     * @param parameterName name of the pagedef parameter     * @return evaluated value of the parameter as a String     */    public static Object getPageDefParameterValue(String pageDefName, String parameterName) {        BindingContainer bindings = findBindingContainer(pageDefName);        DCParameter param = ((DCBindingContainer) bindings).findParameter(parameterName);        return param.getValue();    }    /**     * Convenience method to find a DCControlBinding as an AttributeBinding     * to get able to then call getInputValue() or setInputValue() on it.     * @param bindingContainer binding container     * @param attributeName name of the attribute binding.     * @return the control value binding with the name passed in.     *     */    public static AttributeBinding findControlBinding(BindingContainer bindingContainer, String attributeName) {        if (attributeName != null) {            if (bindingContainer != null) {                ControlBinding ctrlBinding = bindingContainer.getControlBinding(attributeName);                if (ctrlBinding instanceof AttributeBinding) {                    return (AttributeBinding) ctrlBinding;                }            }        }        return null;    }    /**     * Convenience method to find a DCControlBinding as a JUCtrlValueBinding     * to get able to then call getInputValue() or setInputValue() on it.     * @param attributeName name of the attribute binding.     * @return the control value binding with the name passed in.     *     */    public static AttributeBinding findControlBinding(String attributeName) {        return findControlBinding(getBindingContainer(), attributeName);    }    /**     * Return the current page's binding container.     * @return the current page's binding container     */    public static BindingContainer getBindingContainer() {        return (BindingContainer) JSFUtils.resolveExpression("#{bindings}");    }    /**     * Return the Binding Container as a DCBindingContainer.     * @return current binding container as a DCBindingContainer     */    public static DCBindingContainer getDCBindingContainer() {        return (DCBindingContainer) getBindingContainer();    }    /**     * Get List of ADF Faces SelectItem for an iterator binding.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iteratorName ADF iterator binding name     * @param valueAttrName name of the value attribute to use     * @param displayAttrName name of the attribute from iterator rows to display     * @return ADF Faces SelectItem for an iterator binding     */    public static List<SelectItem> selectItemsForIterator(String iteratorName, String valueAttrName,                                                          String displayAttrName) {        return selectItemsForIterator(findIterator(iteratorName), valueAttrName, displayAttrName);    }    /**     * Get List of ADF Faces SelectItem for an iterator binding with description.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iteratorName ADF iterator binding name     * @param valueAttrName name of the value attribute to use     * @param displayAttrName name of the attribute from iterator rows to display     * @param descriptionAttrName name of the attribute to use for description     * @return ADF Faces SelectItem for an iterator binding with description     */    public static List<SelectItem> selectItemsForIterator(String iteratorName, String valueAttrName,                                                          String displayAttrName, String descriptionAttrName) {        return selectItemsForIterator(findIterator(iteratorName), valueAttrName, displayAttrName, descriptionAttrName);    }    /**     * Get List of attribute values for an iterator.     * @param iteratorName ADF iterator binding name     * @param valueAttrName value attribute to use     * @return List of attribute values for an iterator     */    public static List attributeListForIterator(String iteratorName, String valueAttrName) {        return attributeListForIterator(findIterator(iteratorName), valueAttrName);    }    /**     * Get List of Key objects for rows in an iterator.     * @param iteratorName iterabot binding name     * @return List of Key objects for rows     */    public static List<Key> keyListForIterator(String iteratorName) {        return keyListForIterator(findIterator(iteratorName));    }    /**     * Get List of Key objects for rows in an iterator.     * @param iter iterator binding     * @return List of Key objects for rows     */    public static List<Key> keyListForIterator(DCIteratorBinding iter) {        List<Key> attributeList = new ArrayList<Key>();        for (Row r : iter.getAllRowsInRange()) {            attributeList.add(r.getKey());        }        return attributeList;    }    /**     * Get List of Key objects for rows in an iterator using key attribute.     * @param iteratorName iterator binding name     * @param keyAttrName name of key attribute to use     * @return List of Key objects for rows     */    public static List<Key> keyAttrListForIterator(String iteratorName, String keyAttrName) {        return keyAttrListForIterator(findIterator(iteratorName), keyAttrName);    }    /**     * Get List of Key objects for rows in an iterator using key attribute.     *     * @param iter iterator binding     * @param keyAttrName name of key attribute to use     * @return List of Key objects for rows     */    public static List<Key> keyAttrListForIterator(DCIteratorBinding iter, String keyAttrName) {        List<Key> attributeList = new ArrayList<Key>();        for (Row r : iter.getAllRowsInRange()) {            attributeList.add(new Key(new Object[] { r.getAttribute(keyAttrName) }));        }        return attributeList;    }    /**     * Find an iterator binding in the current binding container by name.     *     * @param name iterator binding name     * @return iterator binding     */    public static DCIteratorBinding findIterator(String name) {        DCIteratorBinding iter = getDCBindingContainer().findIteratorBinding(name);        if (iter == null) {            throw new RuntimeException("Iterator '" + name + "' not found");        }        return iter;    }    /**     * @param bindingContainer     * @param iterator     * @return     */    public static DCIteratorBinding findIterator(String bindingContainer, String iterator) {        DCBindingContainer bindings = (DCBindingContainer) JSFUtils.resolveExpression("#{" + bindingContainer + "}");        if (bindings == null) {            throw new RuntimeException("Binding container '" + bindingContainer + "' not found");        }        DCIteratorBinding iter = bindings.findIteratorBinding(iterator);        if (iter == null) {            throw new RuntimeException("Iterator '" + iterator + "' not found");        }        return iter;    }    /**     * @param name     * @return     */    public static JUCtrlValueBinding findCtrlBinding(String name) {        JUCtrlValueBinding rowBinding = (JUCtrlValueBinding) getDCBindingContainer().findCtrlBinding(name);        if (rowBinding == null) {            throw new RuntimeException("CtrlBinding " + name + "' not found");        }        return rowBinding;    }    /**     * Find an operation binding in the current binding container by name.     *     * @param name operation binding name     * @return operation binding     */    public static OperationBinding findOperation(String name) {        OperationBinding op = getDCBindingContainer().getOperationBinding(name);        if (op == null) {            throw new RuntimeException("Operation '" + name + "' not found");        }        return op;    }    /**     * Find an operation binding in the current binding container by name.     *     * @param bindingContianer binding container name     * @param opName operation binding name     * @return operation binding     */    public static OperationBinding findOperation(String bindingContianer, String opName) {        DCBindingContainer bindings = (DCBindingContainer) JSFUtils.resolveExpression("#{" + bindingContianer + "}");        if (bindings == null) {            throw new RuntimeException("Binding container '" + bindingContianer + "' not found");        }        OperationBinding op = bindings.getOperationBinding(opName);        if (op == null) {            throw new RuntimeException("Operation '" + opName + "' not found");        }        return op;    }    /**     * Get List of ADF Faces SelectItem for an iterator binding with description.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iter ADF iterator binding     * @param valueAttrName name of value attribute to use for key     * @param displayAttrName name of the attribute from iterator rows to display     * @param descriptionAttrName name of the attribute for description     * @return ADF Faces SelectItem for an iterator binding with description     */    public static List<SelectItem> selectItemsForIterator(DCIteratorBinding iter, String valueAttrName,                                                          String displayAttrName, String descriptionAttrName) {        List<SelectItem> selectItems = new ArrayList<SelectItem>();        for (Row r : iter.getAllRowsInRange()) {            selectItems.add(new SelectItem(r.getAttribute(valueAttrName), (String) r.getAttribute(displayAttrName),                                           (String) r.getAttribute(descriptionAttrName)));        }        return selectItems;    }    /**     * Get List of ADF Faces SelectItem for an iterator binding.     *     * Uses the value of the 'valueAttrName' attribute as the key for     * the SelectItem key.     *     * @param iter ADF iterator binding     * @param valueAttrName name of value attribute to use for key     * @param displayAttrName name of the attribute from iterator rows to display     * @return ADF Faces SelectItem for an iterator binding     */    public static List<SelectItem> selectItemsForIterator(DCIteratorBinding iter, String valueAttrName,                                                          String displayAttrName) {        List<SelectItem> selectItems = new ArrayList<SelectItem>();        for (Row r : iter.getAllRowsInRange()) {            selectItems.add(new SelectItem(r.getAttribute(valueAttrName), (String) r.getAttribute(displayAttrName)));        }        return selectItems;    }    /**     * Get List of ADF Faces SelectItem for an iterator binding.     *     * Uses the rowKey of each row as the SelectItem key.     *     * @param iteratorName ADF iterator binding name     * @param displayAttrName name of the attribute from iterator rows to display     * @return ADF Faces SelectItem for an iterator binding     */    public static List<SelectItem> selectItemsByKeyForIterator(String iteratorName, String displayAttrName) {        return selectItemsByKeyForIterator(findIterator(iteratorName), displayAttrName);    }    /**     * Get List of ADF Faces SelectItem for an iterator binding with discription.     *     * Uses the rowKey of each row as the SelectItem key.     *     * @param iter ADF iterator binding     * @param displayAttrName name of the attribute from iterator rows to display     * @param descriptionAttrName name of the attribute for description     * @return ADF Faces SelectItem for an iterator binding with discription     */    public static List<SelectItem> selectItemsByKeyForIterator(DCIteratorBinding iter, String displayAttrName,                                                               String descriptionAttrName) {        List<SelectItem> selectItems = new ArrayList<SelectItem>();        for (Row r : iter.getAllRowsInRange()) {            selectItems.add(new SelectItem(r.getKey(), (String) r.getAttribute(displayAttrName),                                           (String) r.getAttribute(descriptionAttrName)));        }        return selectItems;    }    /**     * Find the BindingContainer for a page definition by name.     *     * Typically used to refer eagerly to page definition parameters. It is     * not best practice to reference or set bindings in binding containers     * that are not the one for the current page.     *     * @param pageDefName name of the page defintion XML file to use     * @return BindingContainer ref for the named definition     */    private static BindingContainer findBindingContainer(String pageDefName) {        BindingContext bctx = getDCBindingContainer().getBindingContext();        BindingContainer foundContainer = bctx.findBindingContainer(pageDefName);        return foundContainer;    }    /**     * @param opList     */    public static void printOperationBindingExceptions(List opList) {        if (opList != null && !opList.isEmpty()) {            for (Object error : opList) {                Logger.getLogger(Logger.GLOBAL_LOGGER_NAME).log(Level.WARNING, error.toString());            }        }    }    public static void saveAndContinue() {        Map sessionMap = FacesContext.getCurrentInstance()                                     .getExternalContext()                                     .getSessionMap();        BindingContext context = (BindingContext) sessionMap.get(BindingContext.CONTEXT_ID);        String currentFrameName = context.getCurrentDataControlFrame();        DataControlFrame dcFrame = context.findDataControlFrame(currentFrameName);        dcFrame.commit();        dcFrame.beginTransaction(null);    }    /**     * Programmatic evaluation of EL.     *     * @param el EL to evaluate     * @return Result of the evaluation     */    public static Object evaluateEL(String el) {        FacesContext facesContext = FacesContext.getCurrentInstance();        ELContext elContext = facesContext.getELContext();        ExpressionFactory expressionFactory = facesContext.getApplication().getExpressionFactory();        ValueExpression exp = expressionFactory.createValueExpression(elContext, el, Object.class);        return exp.getValue(elContext);    }    /**     * Programmatic invocation of a method that an EL evaluates to.     * The method must not take any parameters.     *     * @param el EL of the method to invoke     * @return Object that the method returns     */    public static Object invokeEL(String el) {        return invokeEL(el, new Class[0], new Object[0]);    }    /**     * Programmatic invocation of a method that an EL evaluates to.     *     * @param el EL of the method to invoke     * @param paramTypes Array of Class defining the types of the parameters     * @param params Array of Object defining the values of the parametrs     * @return Object that the method returns     */    public static Object invokeEL(String el, Class[] paramTypes, Object[] params) {        FacesContext facesContext = FacesContext.getCurrentInstance();        ELContext elContext = facesContext.getELContext();        ExpressionFactory expressionFactory = facesContext.getApplication().getExpressionFactory();        MethodExpression exp = expressionFactory.createMethodExpression(elContext, el, Object.class, paramTypes);        return exp.invoke(elContext, params);    }    /**     * Sets a value into an EL object. Provides similar functionality to     * not an EL. You can get similar behavior by using the following...     * setEL(to, evaluateEL(from))     *     * @param el EL object to assign a value     * @param val Value to assign     */    public static void setEL(String el, Object val) {        FacesContext facesContext = FacesContext.getCurrentInstance();        ELContext elContext = facesContext.getELContext();        ExpressionFactory expressionFactory = facesContext.getApplication().getExpressionFactory();        ValueExpression exp = expressionFactory.createValueExpression(elContext, el, Object.class);        exp.setValue(elContext, val);    }}